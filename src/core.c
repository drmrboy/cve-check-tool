/*
 * core.c - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE
#include "config.h"

#include <curl/curl.h>
#include <fcntl.h>
#include <gio/gio.h>
#include <glib.h>
#include <inttypes.h>
#ifdef USE_XML
#include <libxml/xmlreader.h>
#else
#include <jansson.h>
#endif
#include <malloc.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

#include "core.h"
#include "cve-check-tool.h"

#include "cve-string.h"
#include "util.h"

#include <sqlite3.h>

const char *nvd_file = "nvd.db";
const char *nvd_dir = "NVDS";
bool use_frac_compare = false;

struct CveDB {
#ifdef USE_XML
        /** XML traversal state */
        bool in_list;
        bool in_entry;
        bool in_product;
        bool in_summary;

        bool in_link;
        bool in_vuln_cvss;
        bool in_base_metrics;
        bool in_score;
        bool in_vector;
        bool in_date;

        xmlChar *cur_id;
        xmlChar *summary;
        xmlChar *score;
        xmlChar *vector;
        xmlChar *modified;
        GList *uris;
#else
        const char *cur_id;
#endif

        /* SQL usage */
        sqlite3 *db;
        sqlite3_stmt *insert;
        sqlite3_stmt *insert_product;
        sqlite3_stmt *search_product;
        sqlite3_stmt *get_cve;
};

#define TABLE_NAME "NVD"

static bool ensure_table(CveDB *self)
{
        if (!self || !self->db) {
                return false;
        }
        int rc = 0;
        char *err = NULL;
        const char *query;

        /* If we crash we've already broken our DB anyway. */
        query = "PRAGMA synchronous = OFF;PRAGMA journal_mode = MEMORY;";
        rc = sqlite3_exec(self->db, query, NULL, NULL, &err);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "ensure_table(): %s\n", err);
                sqlite3_free(err);
                return false;
        }

        query = "CREATE TABLE IF NOT EXISTS " TABLE_NAME
                " "
#ifdef USE_XML
                "(ID TEXT UNIQUE, SUMMARY TEXT, SCORE TEXT, MODIFIED INTEGER, VECTOR TEXT);";
#else
                "(ID TEXT UNIQUE, SUMMARY TEXT, SCORE DOUBLE, MODIFIED INTEGER, VECTOR TEXT);";
#endif
        rc = sqlite3_exec(self->db, query, NULL, NULL, &err);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "ensure_table(): %s\n", err);
                sqlite3_free(err);
                return false;
        }

        query =
            "CREATE TABLE IF NOT EXISTS PRODUCTS (HASH INTEGER UNIQUE, ID TEXT, VENDOR TEXT, PRODUCT TEXT, VERSION "
            "TEXT);";
        rc = sqlite3_exec(self->db, query, NULL, NULL, &err);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "ensure_table(): %s\n", err);
                sqlite3_free(err);
                return false;
        }
        if (err) {
                sqlite3_free(err);
        }

        return true;
}

struct cve_entry_t *cve_db_get_cve(CveDB *self, char *id)
{
        struct cve_entry_t *t = NULL;
        int rc = 0;

        if (!self || !self->db || !id) {
                return NULL;
        }

        sqlite3_reset(self->get_cve);

        if (sqlite3_bind_text(self->get_cve, 1, id, -1, SQLITE_STATIC) != SQLITE_OK) {
                fprintf(stderr, "cve_db_get_cve(): %s\n", sqlite3_errmsg(self->db));
                return NULL;
        }

        rc = sqlite3_step(self->get_cve);
        if (rc != SQLITE_ROW) {
                fprintf(stderr, "cve_db_get_cve(): %s\n", sqlite3_errmsg(self->db));
                return NULL;
        }

        // ID TEXT UNIQUE, SUMMARY TEXT, SCORE TEXT, MODIFIED INTEGER, VECTOR TEXT
        t = calloc(1, sizeof(struct cve_entry_t));
        if (!t) {
                fprintf(stderr, "cve_db_get_cve(): Memory failure\n");
                return NULL;
        }

        t->id = g_strdup((const char *)sqlite3_column_text(self->get_cve, 0));
        t->summary = g_strdup((const char *)sqlite3_column_text(self->get_cve, 1));
#ifdef USE_XML
        t->score = g_strdup((const char *)sqlite3_column_text(self->get_cve, 2));
#else
        t->score = g_strdup_printf("%f", sqlite3_column_double(self->get_cve, 2));
#endif
        t->modified = sqlite3_column_int64(self->get_cve, 3);
        t->vector = g_strdup((const char *)sqlite3_column_text(self->get_cve, 4));

        return t;
}

GList *cve_db_get_issues_frac_compare(CveDB *self, char *product, char *version)
{
        int rc = 0;
        GList *list = NULL;
        int ret = 0;

        if (!self || !self->db) {
                return NULL;
        }

        sqlite3_reset(self->search_product);

        if (sqlite3_bind_text(self->search_product, 1, product, -1, SQLITE_STATIC) != SQLITE_OK) {
                fprintf(stderr, "cve_db_get_issues_frac_compare(): %s\n", sqlite3_errmsg(self->db));
                return NULL;
        }

        while ((rc = sqlite3_step(self->search_product)) == SQLITE_ROW) {
                if ((const char *)sqlite3_column_text(self->search_product, 1) == NULL) /*skip over (null) product*/
                        continue;
                if ((const char *)sqlite3_column_text(self->search_product, 2) == NULL) /*skip over (null) version*/
                        continue;

                ret = strverscmp(version, (const char *)sqlite3_column_text(self->search_product, 2));
                if (ret <= 0) { /* our version <= NVD version */
                        list =
                            g_list_append(list, g_strdup((const char *)sqlite3_column_text(self->search_product, 0)));
                }
        }

        if (rc != SQLITE_DONE) {
                if (list) {
                        g_list_free_full(list, g_free);
                        return NULL;
                }
        }

        return list;
}

GList *cve_db_get_issues(CveDB *self, char *product, char *version)
{
        int rc = 0;
        GList *list = NULL;

        if (!self || !self->db) {
                return NULL;
        }

        sqlite3_reset(self->search_product);

        /* Product */
        if (sqlite3_bind_text(self->search_product, 1, product, -1, SQLITE_STATIC) != SQLITE_OK) {
                fprintf(stderr, "cve_db_get_issues(): %s\n", sqlite3_errmsg(self->db));
                goto bail;
        }
        /* Version */
        if (sqlite3_bind_text(self->search_product, 2, version, -1, SQLITE_STATIC) != SQLITE_OK) {
                fprintf(stderr, "cve_db_get_issues(): %s\n", sqlite3_errmsg(self->db));
                goto bail;
        }
        while ((rc = sqlite3_step(self->search_product) == SQLITE_ROW)) {
                list = g_list_append(list, g_strdup((const gchar *)sqlite3_column_text(self->search_product, 0)));
        }
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_get_issues(): %s\n", sqlite3_errmsg(self->db));
                if (list) {
                        g_list_free_full(list, g_free);
                        return NULL;
                }
        }
bail:
        return list;
}

#ifdef USE_XML
static inline void free_vuln(struct vulnerability_t *t)
{
        if (!t) {
                return;
        }
        if (t->vendor) {
                g_free(t->vendor);
        }
        if (t->product) {
                g_free(t->product);
        }
        if (t->version) {
                g_free(t->version);
        }
}

/**
 * Parse a CPE line into a consumable form
 *
 * @param inp cpe:/ identifier string
 * @param vuln Where to store the resulting vulnerability data
 * @return a boolean value, true if the operation succeeded
 */
static bool parse_vuln(char *cve_id, const xmlChar *inp, struct vulnerability_t *vuln)
{
        gchar *product = NULL;
        gchar *vendor = NULL;
        gchar *version = NULL;
        autofree(gchar) *hash = NULL;

        int len = 0;
        /* Example: cpe:/a:oracle:siebel_crm:8.1.1 */
        gchar **splits = g_strsplit((const gchar *)inp, ":", 10);
        if ((len = g_strv_length(splits)) < 4) {
                g_strfreev(splits);
                return false;
        }

        vendor = g_strdup(splits[2]);
        product = g_strdup(splits[3]);
        if (len > 4) {
                version = g_strdup(splits[4]);
        }
        g_strfreev(splits);

        vuln->vendor = vendor;
        vuln->product = product;
        vuln->version = version;

        hash = g_strdup_printf("%s:%s:%s:%s", cve_id, vendor, product, version);
        if (!hash) {
                fprintf(stderr, "parse_vuln(): Out of memory\n");
                free_vuln(vuln);
                return false;
        }
        vuln->hash = g_str_hash(hash);

        return true;
}

static inline void _cve_db_clean(CveDB *self)
{
        if (self->uris) {
                g_list_free_full(self->uris, xmlFree);
                self->uris = NULL;
        }

        if (self->score) {
                xmlFree(self->score);
                self->score = NULL;
        }
        if (self->vector) {
                xmlFree(self->vector);
                self->vector = NULL;
        }
        if (self->cur_id) {
                xmlFree(self->cur_id);
                self->cur_id = NULL;
        }
        if (self->summary) {
                xmlFree(self->summary);
                self->summary = NULL;
        }
        if (self->modified) {
                xmlFree(self->modified);
                self->modified = NULL;
        }
}

/**
 * Main iterator for XML parsing
 *
 * @param r A valid xmlTextReaderPtr (open)
 */
static void process_node(CveDB *self, xmlTextReaderPtr r)
{
        const xmlChar *name = NULL;
        const xmlChar *value = NULL;
        struct vulnerability_t vuln = {.vendor = 0 };
        xmlChar *uri = NULL;
        int64_t last_mod = -1;

        name = xmlTextReaderConstName(r);
        if (!name) {
                return;
        }
        /* New entry */
        if (xmlStrEqual(name, BAD_CAST "entry")) {
                self->in_entry = !self->in_entry;
                if (!self->in_entry) {
                        int rc = 0;
                        last_mod = parse_xml_date((char *)self->modified);

                        sqlite3_reset(self->insert);

                        /* ID */
                        if (sqlite3_bind_text(self->insert, 1, (const char *)self->cur_id, -1, SQLITE_STATIC) !=
                            SQLITE_OK) {
                                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                                goto next;
                        }
                        /* SUMMARY */
                        if (sqlite3_bind_text(self->insert, 2, (const char *)self->summary, -1, SQLITE_STATIC) !=
                            SQLITE_OK) {
                                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                                goto next;
                        }
                        /* SCORE */
                        if (sqlite3_bind_text(self->insert, 3, (const char *)self->score, -1, SQLITE_STATIC) !=
                            SQLITE_OK) {
                                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                                goto next;
                        }
                        /* MODIFIED */
                        if (sqlite3_bind_int64(self->insert, 4, last_mod)) {
                                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                                goto next;
                        }
                        /* VECTOR */
                        if (sqlite3_bind_text(self->insert, 5, (const char *)self->vector, -1, SQLITE_STATIC) !=
                            SQLITE_OK) {
                                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                                goto next;
                        }

                        rc = sqlite3_step(self->insert);
                        if (rc != SQLITE_DONE) {
                                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                        }
                next:
                        _cve_db_clean(self);
                        return;
                }
                if (self->cur_id) {
                        xmlFree(self->cur_id);
                }
                self->cur_id = xmlTextReaderGetAttribute(r, BAD_CAST "id");
                return;
        }
        if (xmlStrEqual(name, BAD_CAST "vuln:references")) {
                self->in_link = !self->in_link;
                return;
        }
        if (self->in_link && xmlStrEqual(name, BAD_CAST "vuln:reference")) {
                uri = xmlTextReaderGetAttribute(r, BAD_CAST "href");
                if (!uri) {
                        return;
                }
                self->uris = g_list_append(self->uris, uri);
                uri = NULL;
        }
        if (xmlStrEqual(name, BAD_CAST "vuln:vulnerable-software-list")) {
                self->in_list = !self->in_list;
                return;
        }
        if (self->in_list && xmlStrEqual(name, BAD_CAST "vuln:product")) {
                self->in_product = !self->in_product;
                return;
        }
        /* Score checking */
        if (xmlStrEqual(name, BAD_CAST "vuln:cvss")) {
                self->in_vuln_cvss = !self->in_vuln_cvss;
                return;
        }
        if (self->in_vuln_cvss && xmlStrEqual(name, BAD_CAST "cvss:base_metrics")) {
                self->in_base_metrics = !self->in_base_metrics;
                return;
        }
        if (self->in_base_metrics && xmlStrEqual(name, BAD_CAST "cvss:score")) {
                self->in_score = !self->in_score;
        }
        if (self->in_base_metrics && xmlStrEqual(name, BAD_CAST "cvss:access-vector")) {
                self->in_vector = !self->in_vector;
        }
        if (self->in_base_metrics && self->in_vector) {
                value = xmlTextReaderConstValue(r);
                if (!value) {
                        return;
                }
                self->vector = xmlStrdup(value);
        }
        if (self->in_base_metrics && self->in_score) {
                value = xmlTextReaderConstValue(r);
                if (!value) {
                        return;
                }
                self->score = xmlStrdup(value);
        }
        /* Get last modified */
        if (xmlStrEqual(name, BAD_CAST "vuln:last-modified-datetime")) {
                self->in_date = !self->in_date;
        }
        if (self->in_date) {
                value = xmlTextReaderConstValue(r);
                if (!value) {
                        return;
                }
                self->modified = xmlStrdup(value);
        }
        /* Product checking */
        if (self->in_list && self->in_product) {
                value = xmlTextReaderConstValue(r);
                int rc = 0;

                if (!value) {
                        return;
                }
                if (!parse_vuln((char *)self->cur_id, value, &vuln)) {
                        return;
                }

                sqlite3_reset(self->insert_product);

                /* HASH */
                if (sqlite3_bind_int(self->insert_product, 1, vuln.hash) != SQLITE_OK) {
                        fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                        goto end_product;
                }

                /* ID */
                if (sqlite3_bind_text(self->insert_product, 2, (const char *)self->cur_id, -1, SQLITE_STATIC) !=
                    SQLITE_OK) {
                        fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                        goto end_product;
                }
                /* VENDOR */
                if (sqlite3_bind_text(self->insert_product, 3, vuln.vendor, -1, SQLITE_STATIC) != SQLITE_OK) {
                        fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                        goto end_product;
                }
                /* PRODUCT */
                if (sqlite3_bind_text(self->insert_product, 4, vuln.product, -1, SQLITE_STATIC) != SQLITE_OK) {
                        fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                        goto end_product;
                }
                /* VERSION */
                if (sqlite3_bind_text(self->insert_product, 5, vuln.version, -1, SQLITE_STATIC) != SQLITE_OK) {
                        fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                        goto end_product;
                }

                /* Commit product. */
                rc = sqlite3_step(self->insert_product);
                if (rc != SQLITE_DONE) {
                        fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                }

        end_product:
                free_vuln(&vuln);
                return;
        }
        if (self->in_entry && xmlStrEqual(name, BAD_CAST "vuln:summary")) {
                self->in_summary = !self->in_summary;
                if (self->in_summary && self->summary) {
                        xmlFree(self->summary);
                        self->summary = NULL;
                }
                return;
        }
        if (self->in_summary) {
                self->summary = xmlTextReaderValue(r);
                return;
        }
}
#else
enum SqliteOrder {
        SqliteOrderID = 1,
        SqliteOrderSummary,
        SqliteOrderScore,
        SqliteOrderModified,
        SqliteOrderVector
};

enum SqliteOrderVuln {
        SqliteOrderVulnHash = 1,
        SqliteOrderVulnID,
        SqliteOrderVulnVendor,
        SqliteOrderVulnProduct,
        SqliteOrderVulnVersion
};

static void SqliteBindJsonText(sqlite3* db, sqlite3_stmt *stmt, size_t ordinal, json_t* str) {
        if (sqlite3_bind_text(stmt, ordinal, json_string_value(str), -1, SQLITE_STATIC) != SQLITE_OK)
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(db));
}

static void SqliteBindInt64(sqlite3* db, sqlite3_stmt *stmt, size_t ordinal, int64_t num) {
        if (sqlite3_bind_int64(stmt, ordinal, num) != SQLITE_OK)
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(db));
}

static void SqliteBindJsonDouble(sqlite3* db, sqlite3_stmt *stmt, size_t ordinal, json_t* num) {
        if (sqlite3_bind_double(stmt, ordinal, json_real_value(num)) != SQLITE_OK)
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(db));
}

static void SqliteBindJsonDescription(sqlite3* db, sqlite3_stmt *stmt, size_t ordinal, json_t* descr) {
        json_t *data = json_object_get(descr, "description_data");
        size_t  size = json_array_size(data);

        for (size_t i = 0; i < size; ++i) {
                json_t *item = json_array_get(data, i);
                json_t *lang = json_object_get(item, "lang");

                if (!strcmp(json_string_value(lang), "en")) {
                        json_t *value = json_object_get(item, "value");

                        SqliteBindJsonText(db, stmt, ordinal, value);
                        break;
                }
        }
}

static void SqliteBindJsonCveMetadata(CveDB *self, size_t ordinal, json_t* descr) {
        json_t* data    = json_object_get(descr, "ID");
        const char* str = json_string_value(data);

        if (sqlite3_bind_text(self->insert, ordinal, str, -1, SQLITE_STATIC) != SQLITE_OK) {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }

        /* Set current cve id for later use */
        self->cur_id = str;
}

static void SqliteBindVuln(CveDB *self, struct vulnerability_t* vuln) {
        autofree(gchar) *hash = NULL;

        if (vuln->version) {
                hash = g_strdup_printf("%s:%s:%s:%s", self->cur_id, vuln->vendor, vuln->product, vuln->version);
        }
        else {
                hash = g_strdup_printf("%s:%s:%s:*", self->cur_id, vuln->vendor, vuln->product);
        }
        vuln->hash = g_str_hash(hash);

        sqlite3_reset(self->insert_product);

        if (sqlite3_bind_int(self->insert_product, SqliteOrderVulnHash, vuln->hash) != SQLITE_OK) {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }
        if (sqlite3_bind_text(self->insert_product, SqliteOrderVulnID,
            self->cur_id, -1, SQLITE_STATIC) != SQLITE_OK)
        {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }
        if (sqlite3_bind_text(self->insert_product, SqliteOrderVulnVendor,
            vuln->vendor, -1, SQLITE_STATIC) != SQLITE_OK)
        {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }
        if (sqlite3_bind_text(self->insert_product, SqliteOrderVulnProduct,
            vuln->product, -1, SQLITE_STATIC) != SQLITE_OK)
        {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }
        if (sqlite3_bind_text(self->insert_product, SqliteOrderVulnVersion,
            vuln->version, -1, SQLITE_STATIC) != SQLITE_OK)
        {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }

        if (sqlite3_step(self->insert_product) != SQLITE_DONE) {
                fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
        }
}

static void process_versions(CveDB *self, json_t *r, struct vulnerability_t* vuln) {
        size_t size = json_array_size(r);

        if (size == 0) {
                vuln->version = NULL;
                SqliteBindVuln(self, vuln);
                return;
        }

        for (size_t i = 0; i < size; ++i) {
                json_t* version_node  = json_array_get(r, i);
                json_t* version_value = json_object_get(version_node, "version_value");

                vuln->version = json_string_value(version_value);

                SqliteBindVuln(self, vuln);
        }
}

static void process_affects(CveDB *self, json_t *r) {
        json_t *vendor      = json_object_get(r, "vendor");
        json_t *vendor_data = json_object_get(vendor, "vendor_data");
        size_t size = json_array_size(vendor_data);

        struct vulnerability_t vuln;

        for (size_t v = 0; v < size; ++v) {
                json_t *node = json_array_get(vendor_data, v);
                json_t *vendor_name = json_object_get(node, "vendor_name");

                vuln.vendor = json_string_value(vendor_name);

                json_t *product      = json_object_get(node, "product");
                json_t *product_data = json_object_get(product, "product_data");
                size_t products_size = json_array_size(product_data);

                for (size_t p = 0; p < products_size; ++p) {
                        json_t *product_node = json_array_get(product_data, p);
                        json_t *product_name = json_object_get(product_node, "product_name");

                        vuln.product = json_string_value(product_name);

                        json_t *version      = json_object_get(product_node, "version");
                        json_t *version_data = json_object_get(version, "version_data");

                        process_versions(self, version_data, &vuln);
                }
        }
}

static void process_cve(CveDB *self, json_t *r) {
        json_t *cve_data_meta = json_object_get(r, "CVE_data_meta");
        json_t *description   = json_object_get(r, "description");
        json_t *affects       = json_object_get(r, "affects");

        SqliteBindJsonCveMetadata(self, SqliteOrderID, cve_data_meta);
        SqliteBindJsonDescription(self->db, self->insert, SqliteOrderSummary, description);

        process_affects(self, affects);
}

static void process_impact(CveDB *self, json_t *r) {
        json_t *metric = json_object_get(r, "baseMetricV2");
        json_t *cvss   = json_object_get(metric, "cvssV2");
        json_t *score  = json_object_get(cvss, "baseScore");
        json_t *vector = json_object_get(cvss, "accessVector");

        SqliteBindJsonDouble(self->db, self->insert, SqliteOrderScore,  score);
        SqliteBindJsonText  (self->db, self->insert, SqliteOrderVector, vector);
}

static void process_last_modified(CveDB *self, json_t *r) {
        const char *date = json_string_value(r);
        int64_t last_mod = parse_date(date);

        SqliteBindInt64(self->db, self->insert, SqliteOrderModified, last_mod);
}

static bool process_json(CveDB *self, json_t *r) {
        json_t *cve_items = json_object_get(r, "CVE_Items");

        size_t size = json_array_size(cve_items);
        if (size == 0) {
                fprintf(stderr, "process_json(): 'CVE_Items array' not found or empty\n");
                return false;
        }

        for (size_t i = 0; i < size; ++i) {
                sqlite3_reset(self->insert);

                json_t *node = json_array_get(cve_items, i);

                process_cve(self, json_object_get(node, "cve"));
                process_last_modified(self, json_object_get(node, "lastModifiedDate"));
                process_impact(self, json_object_get(node, "impact"));

                if (sqlite3_step(self->insert) != SQLITE_DONE) {
                        fprintf(stderr, "process_node(): %s\n", sqlite3_errmsg(self->db));
                }
        }

        return true;
}

static json_t *load_json(const char *filename) {
        json_t *root;
        json_error_t error;

        root = json_load_file(filename, 0, &error);

        if (root) {
                return root;
        } else {
                fprintf(stderr, "Json error: %s:%d: %s\n", filename, error.line, error.text);
                return (json_t*)0;
        }
}
#endif

/**
 * Parse an NVD xml database
 *
 * @param fname Path to the nvd db
 * @return a boolean value, true if the operation succeeded
 */
bool cve_db_load(CveDB *self, const char *fname)
{
        bool b = false;
        __attribute__((unused)) int rc;

        if (!self || !fname) {
                return false;
        }
#ifdef USE_XML
        int fd = 0;

        fd = open(fname, O_RDONLY);
        if (fd < 0) {
                return false;
        }
        /* If it fails, it fails */
        rc = posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL);

        xmlTextReaderPtr r = xmlReaderForFd(fd, fname, NULL, 0);
        if (!r) {
                close(fd);
                return false;
        }
        int ret;

        while ((ret = xmlTextReaderRead(r)) > 0) {
                process_node(self, r);
        }

        b = true;
#ifdef HAVE_MALLOC_TRIM
        malloc_trim(0);
#endif
        xmlFreeTextReader(r);

        if (fd) {
                close(fd);
        }
#else
fprintf(stderr, "cve_db_load load_json...\n");
        json_t* r = load_json(fname);
        if (r == (json_t*)0) {
fprintf(stderr, "cve_db_load load_json failed: %s:\n", fname);
            return false;
        }
        b = process_json(self, r);

        json_decref(r);
#ifdef HAVE_MALLOC_TRIM
        malloc_trim(0);
#endif
#endif
        return b;
}

bool cve_db_finalize(CveDB *self)
{
        int rc;
        const char *query;

        rc = sqlite3_exec(self->db, "END TRANSACTION;", NULL, NULL, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_finalize(): %s\n", sqlite3_errmsg(self->db));
                return false;
        }

        query = "CREATE INDEX IF NOT EXISTS PRODUCT_IDX ON PRODUCTS (PRODUCT, VERSION);";
        rc = sqlite3_exec(self->db, query, NULL, NULL, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_finalize(): %s\n", sqlite3_errmsg(self->db));
                return false;
        }
        return true;
}

bool cve_db_begin(CveDB *self)
{
        int rc;

        rc = sqlite3_exec(self->db, "BEGIN TRANSACTION;", NULL, NULL, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_begin(): %s\n", sqlite3_errmsg(self->db));
                return false;
        }
        return true;
}

CveDB *cve_db_new(const char *path)
{
        CveDB *ret = NULL;
        sqlite3 *r = NULL;
        int rc = 0;
        const char *q;
        sqlite3_stmt *stm = NULL;

        ret = calloc(1, sizeof(struct CveDB));
        if (!ret) {
                fprintf(stdout, "cve_db_new: Out of memory\n");
                return NULL;
        }

        rc = sqlite3_open(path, &r);
        if (rc != SQLITE_OK) {
                if (r) {
                        sqlite3_close(r);
                }
                free(ret);
                return NULL;
        }
        ret->db = r;

        if (!ensure_table(ret)) {
                fprintf(stderr, "cve_db_new(): Table construction failure\n");
                cve_db_free(ret);
                return NULL;
        }

        q = "INSERT OR REPLACE INTO " TABLE_NAME " VALUES (?, ?, ?, ?, ?);";

        rc = sqlite3_prepare_v2(ret->db, q, -1, &stm, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_new(): %s\n", sqlite3_errmsg(ret->db));
                cve_db_free(ret);
                return NULL;
        }
        ret->insert = stm;
        stm = NULL;

        /* Insert product. */
        q = "INSERT OR REPLACE INTO PRODUCTS VALUES (?, ?, ?, ?, ?)";
        rc = sqlite3_prepare_v2(ret->db, q, -1, &stm, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_new(): %s\n", sqlite3_errmsg(ret->db));
                cve_db_free(ret);
                return NULL;
        }
        ret->insert_product = stm;
        stm = NULL;

        /* Search product. */
        if (use_frac_compare) {
                q = "select ID, PRODUCT, VERSION from PRODUCTS where PRODUCT = ?";
        } else {
                q = "SELECT ID FROM PRODUCTS WHERE PRODUCT = ? AND VERSION = ? COLLATE NOCASE";
        }
        rc = sqlite3_prepare_v2(ret->db, q, -1, &stm, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_new(): %s\n", sqlite3_errmsg(ret->db));
                cve_db_free(ret);
                return NULL;
        }
        ret->search_product = stm;
        stm = NULL;

        /* Get CVE. */
        q = "SELECT * FROM NVD WHERE ID = ?";
        rc = sqlite3_prepare_v2(ret->db, q, -1, &stm, NULL);
        if (rc != SQLITE_OK) {
                fprintf(stderr, "cve_db_new(): %s\n", sqlite3_errmsg(ret->db));
                cve_db_free(ret);
                return NULL;
        }
        ret->get_cve = stm;
        stm = NULL;

        return ret;
}

void cve_db_free(CveDB *self)
{
        if (!self) {
                return;
        }
        if (self->insert) {
                sqlite3_finalize(self->insert);
        }
        if (self->insert_product) {
                sqlite3_finalize(self->insert_product);
        }
        if (self->search_product) {
                sqlite3_finalize(self->search_product);
        }
        if (self->get_cve) {
                sqlite3_finalize(self->get_cve);
        }
        if (self->db) {
                sqlite3_close(self->db);
        }
#ifdef USE_XML
        _cve_db_clean(self);
#endif
        free(self);
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
